# doc-cache created by Octave 6.4.0
# name: cache
# type: cell
# rows: 3
# columns: 8
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
install_vars


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1129
 -- Function File: install_vars (VARNAME, ..., CONNECTIONS)
     Install named variables at remote machines.

     The variables named in the arguments are distrubted to the remote
     machines specified by CONNECTIONS and installed there.  The
     variables must be accessible within the calling function.  If
     variables have been declared to have global scope, they will also
     have global scope at the remote machines.

     This function can only be successfully called at the client
     machine.  See 'pconnect' for a description of the CONNECTIONS
     variable.  CONNECTIONS can contain all connections of the network,
     a subset of them, or a single connection.  The local machine
     (client), if contained in CONNECTIONS, is ignored.

     To install, e.g., all visible variables,

     'install_vars (who (){:}, ...);'

     can be used.

     Internally, this function sends the variables only to one server
     and then issues the necessary commands to distribute them to all
     specified servers over server-to-server data connections.

     See also: pconnect, pserver, sclose, rfeval, netcellfun.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Install named variables at remote machines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
netarrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 845
 -- Function File: netarrayfun (CONNECTIONS, FUN, ...)
     Evaluates function FUN in a parallel cluster and collects results.

     This function handles arguments and options equivalently to
     'pararrayfun' and returnes equivalent output.  Differently, the
     first argument specifies server machines for parallel remote
     execution, see 'pconnect' for a description of the CONNECTIONS
     variable.  A further difference is that the option "ChunksPerProc"
     is ignored and instead the chunk size can be specified directly
     with an option "ChunkSize" (option "Vectorized" can be used
     together with option "ChunkSize" in function 'netarrayfun').

     The further details of operation are the same as for 'netcellfun',
     please see there.

     See also: netcellfun, pconnect, pserver, sclose, rfeval,
     install_vars.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Evaluates function FUN in a parallel cluster and collects results.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
netcellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2179
 -- Function File: netcellfun (CONNECTIONS, FUN, ...)
     Evaluates function FUN in a parallel cluster and collects results.

     This function handles arguments and options equivalently to
     'parcellfun' and returnes equivalent output.  Differently, the
     first argument specifies server machines for parallel remote
     execution, see 'pconnect' for a description of the CONNECTIONS
     variable.  A further difference is that the option "ChunksPerProc"
     is ignored and instead the chunk size can be specified directly
     with an option "ChunkSize".

     This function can only be successfully called at the client machine
     of the parallel cluster.  CONNECTIONS can contain all connections
     of the network, a subset of them, or a single connection.  The
     local machine (client), if contained in CONNECTIONS, is ignored.
     However, one of the servers can run at the local machine under
     certain conditions (see 'pconnect') and will not be ignored in this
     case, so that the local machine can take part in parallel execution
     with 'netcellfun'.

     As a second level of parallelism, FUN is executed at each server
     machine (using 'parcellfun or pararrayfun') by default in as many
     local processes in parallel as the server has processor cores
     available.  The number of local parallel processes can be
     configured for each server with the "nlocaljobs" option (see
     'network_set'), a value of '0' means that the default value will be
     used, a value of '1' means that execution is not parallel within
     the server (but still parallel over the cluster).

     See 'parallel_doc ("limitations")' for possible limitations e.g.
     on how FUN can be defined.

     Cluster execution incurs a considerable overhead.  A speedup is
     likely if the computation time of FUN is long.  To speed up
     execution of a large set of arguments with short computation times
     of FUN, increase "ChunkSize", possibly use "Vectorize" (see
     'pararrayfun'), and possibly experiment with increasing
     "nlocaljobs" from the default.

     See also: netarrayfun, pconnect, pserver, sclose, rfeval,
     install_vars.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Evaluates function FUN in a parallel cluster and collects results.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
parallel_doc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 415
 -- Function File: parallel_doc ()
 -- Function File: parallel_doc (KEYWORD)
     Show parallel package documentation.

     Runs the info viewer Octave is configured with on the documentation
     in info format of the installed parallel package.  Without
     argument, the top node of the documentation is displayed.  With an
     argument, the respective index entry is searched for and its node
     displayed.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Show parallel package documentation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
pararrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1155
 -- Function File: [O1, O2, ...] = pararrayfun (NPROC, FUN, A1, A2, ...)
 -- Function File: pararrayfun (nproc, fun, ..., "UniformOutput", VAL)
 -- Function File: pararrayfun (nproc, fun, ..., "ErrorHandler",
          ERRFUNC)
     Evaluates a function for corresponding elements of an array.
     Argument and options handling is analogical to 'parcellfun', except
     that arguments are arrays rather than cells.  If cells occur as
     arguments, they are treated as arrays of singleton cells.  Arrayfun
     supports one extra option compared to parcellfun: "Vectorized".
     This option must be given together with "ChunksPerProc" and it
     indicates that FUN is able to operate on vectors rather than just
     scalars, and returns a vector.  The same must be true for ERRFUNC,
     if given.  In this case, the array is split into chunks which are
     then directly served to FUNC for evaluation, and the results are
     concatenated to output arrays.  If "CumFunc" is also specified (see
     'parcellfun'), FUN is expected to return the result of the same
     cumulative operation instead of vectors.

     See also: parcellfun, arrayfun.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Evaluates a function for corresponding elements of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
parcellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2694
 -- Function File: [O1, O2, ...] = parcellfun (NPROC, FUN, A1, A2, ...)
 -- Function File: parcellfun (nproc, fun, ..., "UniformOutput", VAL)
 -- Function File: parcellfun (nproc, fun, ..., "ErrorHandler", ERRFUNC)
 -- Function File: parcellfun (nproc, fun, ..., "VerboseLevel", VAL)
 -- Function File: parcellfun (nproc, fun, ..., "ChunksPerProc", VAL)
 -- Function File: parcellfun (nproc, fun, ..., "CumFunc", CUMFUNC)
     Evaluates a function for multiple argument sets using multiple
     processes in parallel.

     NPROC specifies the number of processes and must be at least 1.  It
     will be cut to the number of available CPU cores or the size of the
     input argument(s), whichever is lower.  FUN is a function handle
     pointing to the requested evaluating function.  A1, A2 etc.  should
     be cell arrays of equal size.  O1, O2 etc.  will be set to
     corresponding output arguments.

     The UniformOutput and ErrorHandler options are supported with
     meaning identical to "cellfun".  If option VerboseLevel is set to 1
     (default is 0), progress messages are printed to stderr.  The
     ChunksPerProc option controls the number of chunks which contains
     elementary jobs.  This option is particularly useful when time
     execution of function is small.  Setting this option to 100 is a
     good choice in most cases.

     Instead of returning a result for each argument, parcellfun returns
     only one cumulative result if "CumFunc" is non-empty.  CUMFUNC must
     be a function which performs an operation on two sets of outputs of
     FUN and returnes as many outputs as FUN.  If NOUT is the number of
     outputs of FUN, CUMFUNC gets a previous output set of FUN or of
     CUMFUNC as first NOUT arguments and the current output of FUN as
     last NOUT arguments.  The performed operation must be
     mathematically commutative and associative.  If the operation is
     e.g.  addition, the result will be the sum(s) of the outputs of FUN
     over all calls of FUN.  Since floating point addition and
     multiplication are only approximately associative, the cumulative
     result will not be exactly reproducible.

     Each process has its own pseudo random number generator, so when
     using this function for example to perform Monte-Carlo simulations
     one generally cannot expect results to be exactly reproducible.
     Exact reproducibility may be achievable by generating the random
     number sequence before calling parcellfun and providing the random
     numbers as arguments to FUN.

     See 'parallel_doc ("limitations")' for possible limitations on how
     FUN can be defined.

     See also: parcellfun_set_nproc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Evaluates a function for multiple argument sets using multiple processes
in p...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pserver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4311
 -- Function File: pserver ()
 -- Function File: pserver (OPTIONS)
 -- Function File: pserver ("kill")
     Starts or stops a server of the parallel cluster.

     OPTIONS: structure of options; field 'use_tls' is 'true' by default
     (TLS with SRP authentication); if set to 'false', there will be no
     encryption or authentication.  Field 'auth_file' can be set to an
     alternative path to the file with authentication information (see
     below).  Fields 'cmd_port' (default: 12502) and 'data_port'
     (default: 12501) can be set to change the ports of the command
     channel and the data channel, respectively.

     If called as 'pserver ("kill")', the server will be stopped by
     sending it a signal, taking its process id from its pid-file
     '/tmp/.octave-<hostname>.pid'.  Otherwise the server will be
     started.

     The servers exectuable file ('octave-pserver') is searched for by
     first assuming the directory structure of a regular package
     installation, then by searching Octaves function search path for
     it, and then by the called shell in its shell search path.

     If a directory path corresponding to the current directory of the
     client exists on the server machine, it will be used as the servers
     current directory for the respective client (multiple clients are
     possible).  Otherwise, '/tmp' will be used.  The Octave functions
     the server is supposed to call and the files it possibly has to
     access must be available at the server machine.  This can e.g.  be
     achieved by having the server machine mount a network file system
     (which is outside the scope of this package documentation).

     If a directory path corresponding to the current directory of the
     client exists on the server machine, it will be used as the servers
     current directory for the respective client (multiple clients are
     possible).  Otherwise, '/tmp' will be used.  The Octave functions
     the server is supposed to call and the files it possibly has to
     access must be available at the server machine.  This can e.g.  be
     achieved by having the server machine mount a network file system
     (which is outside the scope of this package documentation).

     If a connection is accepted from a client, the server collects a
     network identifier and the names of all server machines of the
     network from the client.  Then, connections are automatically
     established between all machines of the network.  Data exchange
     will be possible between all machines (client or server) in both
     directions.  Commands can only be sent from the client to any
     server.

     The opaque variable holding the network connections, in the same
     order as in the corresponding variable returned by 'pconnect', is
     accessible under the variable name 'sockets' at the server side.
     Do not overwrite or clear this variable.  The own server machine
     will also be contained at some index position of this variable, but
     will not correspond to a real connection.  See 'pconnect' for
     further information.

     The client and the server must both use or both not use TLS. If TLS
     is switched off, different measures must be taken to protect ports
     of the command and data channels at the servers and the client
     against unauthorized access, e.g.  by a firewall or by physical
     isolation of the network.

     For using TLS, authorization data must be present at the server
     machine.  These data can conveniently be generated by
     'parallel_generate_srp_data'; the helptext of the latter function
     documents the expected location of these data.

     The SRP password will be sent over the encrypted TLS channel from
     the client to each server, to avoid permanently storing passwords
     at the server for server-to-server data connections.  Due to
     inevitable usage of external libraries, memory with sensitive data
     can, however, be on the swap device even after shutdown of the
     application.

     The server executable file 'octave-pserver' is installed and runs
     at GNU/Linux, but not at some other operating systems like Windows
     and macOS.

     See also: pconnect, reval, psend, precv, sclose,
     parallel_generate_srp_data, select_sockets.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Starts or stops a server of the parallel cluster.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rfeval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2232
 -- Function File: rfeval (FUNC, ..., NOUT, ISOUT, CONNECTION)
     Evaluate a function at a remote machine.

     FUNC is evaluated with arguments '...' and number of output
     arguments set to NOUT at remote machine given by CONNECTION.  If
     ISOUT is not empty, it must be a logical array with NOUT elements,
     which are true for each of the NOUT output arguments which are
     requested from the function; the other output arguments will be
     marked as not requested with '~' at remote execution.

     This function can only be successfully called at the client
     machine.  See 'pconnect' for a description of the CONNECTION
     variable.  CONNECTION must contain one single connection.

     If an output argument is given to 'rfeval', the function waits for
     completion of the remote function call, retrieves the results and
     returns them.  They will be returned as one cell-array with an
     entry for each output argument.  If some output arguments are
     marked as not requested by setting some elements of ISOUT to false,
     the returned cell-array will only have entries for the requested
     output arguments.  For consistency, the returned cell-array can be
     empty.  To assign the output arguments to single variables, you can
     for example use: '[a, b, c] = returned_cell_array{:};'.

     If no output argument is given to 'rfeval', the function does not
     retrieve the results of the remote function call but returns
     immediately.  It is left to the user to retrieve the results with
     'precv'.  The results will be in the same format as if returned by
     'rfeval'.  Note that a cell-array, possibly empty, will always have
     to be retrieved, even if the remote function call should have been
     performed without output arguments.

     Parallel execution can be achieved by calling 'rfeval' several
     times with different specified server machines before starting to
     retrieve the results.

     The specified function handle can refer to a function present at
     the executing machine or be an anonymous function.  See
     'parallel_doc ("limitations")' for possible limitations.

     See also: pconnect, pserver, sclose, install_vars, netcellfun.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Evaluate a function at a remote machine.





